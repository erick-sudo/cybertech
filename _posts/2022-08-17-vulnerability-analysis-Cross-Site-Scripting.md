---
layout: post
title:  Security Vulnerabilities
subtitle: Cross-Site Scripting Vulnerability
categories: Cross-Site Scripting
tags: [X-XSS]
---

## Cross-Site Scripting (XSS)

### Overview
[Cross-Site Scripting](http://) (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

*Categories of cross-site scripting (XSS) vulnerabilities include:*
    • *Reflected XSS (Non-Persistent or Type I)*
Reflected XSS occurs when user input is immediately returned by a web application in an error message, search result, or any other response that includes some or all of the input provided by the user as part of the request, without that data being made safe to render in the browser, and without permanently storing the user provided data.
    • *Stored XSS (Persistent or Type II)*
Stored XSS generally occurs when user input is stored on the target server, such as in a database, in a message forum, visitor log, comment field, etc. And then a victim is able to retrieve the stored data from the web application without that data being made safe to render in the browser.
    • *DOM Based XSS (Type-0)*
As defined by Amit Klein, who published the first article about this issue [1], DOM Based XSS is a form of XSS where the entire tainted data flow from source to sink takes place in the browser, i.e., the source of the data is in the DOM, the sink is also in the DOM, and the data flow never leaves the browser.

*Security Posture* – An attacker can use XSS to send a malicious script to an unsuspecting user. The end user’s browser has no way to know that the script should not be trusted, and will execute the script. Because it thinks the script came from a trusted source, the malicious script can access any cookies, session tokens, or other sensitive information retained by the browser and used with that site.
These scripts can even rewrite the content of the HTML page.

Example of sensitive transactions susceptible to cross-site request forgery (csrf) attacks, by [ReShift](https://reshiftsecurity.com).

![code susceptible to csrf attacks](/assets/images/vulnerabilities/cross_site_forgery.png)

A Cross Site Request Forgery (CSRF, XSRF) attack relies on HTTP Cookies. When a user initiates a session with the server by logging in the server tracks the session by sending an HTTP Cookie to each subsequent request to the server. The design flaw that CSRF attacks leverage is that the browser is unaware if the URL it was told to follow was caused by the user’s action on the page or by some other action. The server only sees a request from the browser with a valid HTTP Cookie, and cannot differentiate a CSRF request from a valid request.

### Business Impact

The consequence of an XSS attack is the same regardless of whether it is stored or reflected (or DOM Based). The difference is in how the payload arrives at the server. Do not be fooled into thinking that a “read-only” or “brochureware” site is not vulnerable to serious reflected XSS attacks.
XSS can cause a variety of problems for the end user that range in severity from an annoyance to complete account compromise. The most severe XSS attacks involve disclosure of the user’s session cookie, allowing an attacker to hijack the user’s session and take over the account. Other damaging attacks include the disclosure of end user files, installation of Trojan horse programs, redirect the user to some other page or site, or modify presentation of content.
An XSS vulnerability allowing an attacker to modify a press release or news item could affect a company’s stock price or lessen consumer confidence. An XSS vulnerability on a pharmaceutical site could allow an attacker to modify dosage information resulting in an overdose.

If a server provides a *REST API* then *GET HTTP* requests do not change state. Only *POST*, *PUT*, *DELETE* requests change something on the server by creating, updating, or deleting. A successful CSRF attack on a state changing request could purchase, change, or remove something on the user’s account.
The server is unaware that the user did not perform the action since it received a request from a browser with a HTTP Cookie containing a valid session token.
If the request involved changing something in the user account, then there can be expensive consequences.

### Remediations
The ***Synchronizer Token Pattern*** requires the server to generate a highly random session unique value one the user has logged in. The server stores this Synchronizer Token with the user session.
This Synchronizer token can now be returned to the browser on each response either in a special header or in a form variable.

For Example, given the following web page;
```
    <HTML>
    <BODY>
        <form action="/transfer.do" method="post">
        <input type="hidden" name="CSRFToken" value="<some base64 encoded token>">
        ...
        </form>
    </BODY>
    </HTML>
```

Once the user performs an action on the page that generates a request, JavaScript code retrieves the token and returns it in a custom header. A custom header is preferred as it is harder to forge the browsers CORS support will send a preflight request.
Once the server receives the request it extracts the Synchronizer Token in the custom header and verifies it is the correct value for the session. Otherwise, it will reject the request.

The following is a fix example of an Express application that has CSRF protection configured:
let cookieParser = require('cookie-parser')
let csrf = require('csurf')
let bodyParser = require('body-parser')
let express = require('express')
```
    //setup route middlewares
    let csrfProtetion = csrf({ cookie: true })
    let parseForm = bodyParser.urlencoded({ extended: false })

    //create express app
    let app = express()

    //parse cookies
    //we need this because "cookie" is true in csrfProtection
    app.use(cookierParser());

    app.get('/form', csrfProtection, funtion (req, res) {
        //pass the csrfToken to the view
        re.render('send', { csrfToken: req.csrfToken() })
    })

    app.post('/process', parseForm, csrfProtection, function )req, res) {
        res.send('data is being processed');
    })
```

A more proper form other than the previous is:
```
    <form action="/process" method="POST">
        <input type="hidden" name="_csrf" value="{{csrfToken}}">

        Favorite color: <input type="text" name="favoriteColor">
        <button type="submit">Submit</button>
    </form>
```